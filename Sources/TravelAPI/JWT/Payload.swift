//
//  Payload.swift
//  TravelAPI
//
//  Created by Isaque da Silva on 11/11/25.
//


import JWT
import Vapor

/// The JWT Payload representation model.
struct Payload: Content, Authenticatable, JWTPayload {
    /// An unique identifier of this token.
    ///
    /// >Important: Before to access any resource of this API, this id needs to be verified by checking at the ``DisabledTokens`` table,
    /// and only free the access if the id is not contained at the table.
    let jwtID: IDClaim
    
    /// An identifier of the issuer of this token.
    let issuer: IssuerClaim
    
    /// An identifier of the user that claimed for creation of this token.
    ///
    /// >Important: Before to acess any resource of this API, it's necessary to check if the subject exist, by looking at the ``User``'s table,
    /// and seen if the subject matches at an ID of an User.
    let subject: SubjectClaim
    
    /// Indicates what this token is for.
    let audience: AudienceClaim
    
    /// Indicates the creation time of this token.
    let issuedAt: IssuedAtClaim
    
    /// Indicates when this token will be expire.
    let expiration: ExpirationClaim
    
    var userID: UUID? {
        .init(uuidString: self.subject.value)
    }
    
    init(with userID: UUID, audienceType: AudienceType) throws {
        let issuedAt = Date()
        
        let expirationTime: TimeInterval = switch audienceType {
        case .fullAccess:
            // Set the expiration time for 10 minutes after your creation.
            TimeLimit.tenMinutes.rawValue
        case .refresh:
            // Set the expiration time for 7 days after your creation.
            TimeLimit.sevenDays.rawValue
        }
        
        
        let randomNumberInString = "\(Int.random(in: .min ... .max))"
        
        let tokenID = userID.uuidString + randomNumberInString + issuedAt.ISO8601Format()
        
        self.jwtID = .init(value: tokenID)
        self.issuer = try .init(value: EnvironmentValues.jwtIssuer())
        self.subject = .init(value: userID.uuidString)
        self.audience = try audienceType.makeAudience()
        self.issuedAt = .init(value: issuedAt)
        self.expiration = .init(value: issuedAt.addingTimeInterval(expirationTime))
    }
}

extension Payload {
    enum CodingKeys: String, CodingKey {
        case jwtID = "jti"
        case issuer = "iss"
        case subject = "sub"
        case audience = "aud"
        case issuedAt = "iat"
        case expiration = "exp"
    }
}

extension Payload {
    /// Verifies if the current jwt is valid to execute the task.
    func verify(using algorithm: some JWTAlgorithm) async throws {
        try checkIssuer()
        
        try self.verifyAudience(firstValue: self.audience.value[0])
        
        try self.checkIssuedAt()
        
        try self.expiration.verifyNotExpired()
    }
}

extension Payload {
    /// Checks if the given subject in the payload of the token is the same as the original subject generated by this server.
    private func checkIssuer() throws {
        let issuerClaim = try EnvironmentValues.jwtIssuer()
        
        guard issuerClaim == self.issuer.value else {
            throw Abort(.unauthorized)
        }
    }
}

extension Payload {
    /// Check if the issued time is valid.
    ///
    /// To check if the issued time is valid, this method follows some crutials steps:
    /// - First, check if the token was not emitted more than 10 mintues or seven days.(Depends if the token is an access or refresh token).
    /// This verification is important, because a JWT can be modified or captured, and this claim can be modifed.
    /// So, if it's happen, this verification can helps the syetem understand, how old this token is, and check if is safe to trust at this token.
    /// - Last,  we need to verifies if the addition of a time limit at the issued at matches with the expiration time stored at this token.
    /// This verification, helps the system to understand, if the issued time is valid, because, if we add the same constant time interval at the issued time,
    /// your result needs to be the same as the ``expiration`` time. So if it's not matches, we can trust, that this token was modified and we can invalidated the access.
    private func checkIssuedAt() throws {
        let timeLimit: TimeInterval = if self.audience.value[0] == "0" {
            TimeLimit.tenMinutes.rawValue
        } else if self.audience.value[0] == "1" {
            TimeLimit.sevenDays.rawValue
        } else {
            throw Abort(.unauthorized)
        }
        
        let issuedAt = self.issuedAt.value
        let pastTime = Date().addingTimeInterval(-timeLimit)
        let expirationTime = issuedAt.addingTimeInterval(timeLimit)
        
        guard (issuedAt >= pastTime) && (expirationTime == self.expiration.value) else {
            throw Abort(.unauthorized)
        }
    }
}

extension Payload {
    /// Verifies if the given audience is the same as the value stored at the server.
    func verifyAudience(firstValue: String) throws {
        let audience: String = if firstValue == "0" {
            try EnvironmentValues.fullAccessJWTAudience()
        } else if firstValue == "1" {
            try EnvironmentValues.refreshJWTAudience()
        } else {
            throw Abort(.unauthorized)
        }
        
        try self.audience.verifyIntendedAudience(includes: audience)
    }
}

extension Payload {
    enum AudienceType: String {
        case fullAccess = "0"
        case refresh = "1"
        
        func makeAudience() throws -> AudienceClaim {
            var audience = [self.rawValue]
            
            switch self {
            case .fullAccess:
                try audience.insert(EnvironmentValues.fullAccessJWTAudience(), at: 1)
            case .refresh:
                try audience.insert(EnvironmentValues.refreshJWTAudience(), at: 1)
            }
            
            return .init(value: audience)
        }
    }
}

extension Payload {
    enum TimeLimit: TimeInterval {
        case tenMinutes, sevenDays
        
        var rawValue: Double {
            switch self {
            case .tenMinutes:
                return (60 * 10)
            case .sevenDays:
                return (60 * 60 * 24 * 7)
            }
        }
    }
}